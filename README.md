#Hannon Hill Coding Exercise

The purpose of this exercise is to determine if, given some function f which accepts an integer and returns an integer, if that function is additive for every combination of prime numbers less than a given value N.
To be additive, a function must satisfy f(x) + f(y) = f(xy).

I opted to solve this problem in Java, because:
* Java is the language I am most familiar with- both in the language itself, and in supporting infrastructure, especially for testing.
* JUnit and Mockito dramatically simplify test driving solutions.  While comparable libraries and frameworks exist for other languages, I am not as familiar with them.
* The concept of testing a function pushes towards a functional or dynamically typed language.  With Java 8's lambda expressions, this force is less great than it would have been in the past.

To solve this exercise, I identified the following ideas:
* Generate the collection of prime numbers less than N
* Verify if the secret satisfies the additive definition for a given pair of values
* Compare every combination of prime values to see if they satisfy the additive definition

I began by creating an interface, Secret, representing the secret function as described- it has one method (apply) which accepts an integer and returns an integer.

To solve the first, I introduced PrimesSupplier, which accepts an integer and provides a list of integers which are all the prime values less than the given value.
I am building this list in a relatively naive fashion, without a strong eye towards performance- premature optimization is the root of much evil!  That said, I would also request feedback from the business at this stage, regarding expected volume of use, variance between requests, and size of the value.  
If we'll be making lots of calls against a relatively constrained set of values, then it might be reasonable to introduce some form of caching.  
If instead we'll be making a few calls against very large values, then it might be necessary to investigate more efficient prime generating algorithms, or to consider pre-calculating the collection of primes and storing them in a durable location for later retrieval.

To solve the second, I introduced AdditiveCheck, which accepts a Secret and a pair of integers, returning a boolean.
This essentially just encapsulates the definition of additive, making it easy to swap out the kind of function to verify secrets against every combination of values.

(I came about a hair's breadth away from having interfaces for both PrimesSupplier and AdditiveCheck, but ultimately decided that introducing such would be premature)

To solve the third, I wrote SecretCheck to walk through the collection of primes generated by PrimeSupplier, checking each combination against the secret function using an injected AdditiveChecker.
Walking through the combinations is done with nested loops, where the inner loop starts at the current index of the outer loop to avoid redundant pairs (once you have checked the combination 2,3 you don't need to check 3,2)

Finally, I implemented BigOmegaFunction as a Secret; BigOmega is a well known but relatively complex additive function.  It allowed me to write an integration test of the SecretChecker which gave a much higher degree of confidence.

The particulars of the implementations were all test driven.
